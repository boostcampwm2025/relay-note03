# ✔️ 토론하기

### 1. 기존 퀘스트 1: 팀원별 리드미 기반 맞춤형 하루 한 줄 메시지 생성

- 보안 측면에서 LLM을 도입하는데 꺼리는 이유도 기술유출이나 보안측면에서가 큰 이유라고 알고 있다.
- 이렇게 자료를 다 보내는게 큰 관점에서는 보안관련된 문제가 되지않을까? 더군다나 실제 프로젝트라면?
- 부스트캠프의 취지에도 내용 유출이 불가한점이 있는데 지켜지지 않는 문제점
- 보안측면에 있어서 다른 퀘스트로 교체하는 것이 좋겠다.

### 2. 기존 퀘스트 2: GPT 코드 리뷰어 만들기

- 학습용도 개인 코드를 보내고 피드백을 받는데는 문제가 없을 것 같다고 생각한다.
- 피어세션인 1시간 내에 모든 코드를 설명할 수는 없기 때문에, 퀘스트 취지는 좋다고 생각
- 실제 코드리뷰 시에는 작성자에게 의도를 묻기도 함
- 피드백 할 부분을 AI가 캐치한 경우에는 바로 피드백하기보다, 작성자에게 의도 물어보고나서 피드백 해주기

### 3. 기존 퀘스트 3: AI와 함께하는 팀 운세 점치기 (커뮤니티 아이스브레이킹)

- 쉽기도 하고 서로에게 부담되지 않는 가벼운 테스트인 점이 좋다고 생각
- 가끔 오버스러운 과한 표현들이 있다.
- 가벼운 아이스 브레이킹으로 좋아서 크리티컬한 개선점이 보이지 않기 때문에 유지하도록 하자

### 4. 기존 퀘스트 4: AI와의 밈 학습 챌린지

- 가벼운 검증이라해도 잘못된 정보를 받아서 공유한다는 사실을 잊으면 안된다.
- AI를 활용하면서 가장 문제되는 것이 정보의 오류라고 생각한다.
- 럭키비키 생성 밈이라는게 있었는데, 긍정적인 결과가 있어서 좋았다.
- 오히려 좋아 밈 활용해보기? 이를 좋다고 받아들이자는 맥락에서 사용되는 말이자 인터넷 밈의 일종
- 정보보다는 상황적인 부분을 밈으로 유쾌하게 활용하면 좋겠다.

### 5. 번외 토론

- 정보 오류
  - AI가 사용자를 만족시킬 수 있게 맞춰져 있다보니까,
  - 사용자는 긍정적인 표현을 지속적으로 듣다가 마음이 열리고, 잘못된 정보를 자연스레 받아들이는 경우가 있다고 한다.
  - AI가 항상 옳은 정보만 주지는 않는다. 내가 아는만큼 걸러야 함
- 미션에서의 AI 사용성
  - 미션에 주어진 시간이 제한적이고 부족해서 영역에 국한하지 않고 전 과정에서 사용하게 됨
  - 내가 이해한 바가 맞는지 다시 한번 확인하는 차원에서 사용
  - 처음부터 요구사항분석을 잘못하면 이후 과정에서 너무 고생하니까
- 미션에 AI가 없다면
  - 애초에 미션 난이도가 이렇게 높지 않을 것이다.
  - 이미 AI를 사용할거라는 가정하에 이런 애매하고 추상적인 명세를 낸 것이 아닌가 생각한다.
  - 예전에 AI 가 없을 때 전부 구글링을 했었다. 아주 많은 자료를 보고 습득해야함
  - 구글링 능력도 하나의 개발 능력일 거다. 이미 처음 자료 분석부터 큰 차이가 벌어질 듯
  - 이제는 프롬프트를 잘쓰는 것이 능력이 됨.
- 문제 해결 역량 배경
  - 문제 해결 방향을 정하고 AI를 활용한다면, 정보를 거르는 역량이 있지만
  - 아예 아무지식이 없으면 전부 받아들이게 됨
  - 배경 지식에 따라서 AI 사용 이후 결과물 차이가 많이남
- AI 가 없던 경우
  - 한줄을 적더라도 구글링으로 하루가 걸리기도 했다.
  - 대신에 훨씬 내것이 된다는 느낌
  - 그래도 구글조차 없던 개발자 시절에는 원서만 보지 않았을까?
- 개발 블로그
  - 블로그들도 많이 활용한다.
  - 블로그는 자료 출처가 없는 경우가 많다.
  - 자료를 찾을 때 상류로 계속 올라가라, 영어자료, 공식문서를 찾아가라 공식 문서는 본질에 가까운 느낌.
  - 개인 기술 블로그는 해석하고 재해석되고 정리되어 있다. 오류가 포함될 수도 있지 않을까?
    <br>

# ✔️ 개선한 퀘스트

### [퀘스트 1: GPT 코드 리뷰어 만들기 (개선)]

#### 1) 배경

- 코드를 작성하는 것도 중요하지만, 코드를 읽고 개선점을 찾는 능력은 더욱 중요하다.
- 개발자가 혼자 공부할 때는 코드 리뷰를 받을 기회가 적은데, 이럴 때 GPT를 코드 리뷰어처럼 활용하면 도움을 받을 수 있다.
- GPT는 코드 스타일, 성능, 가독성, 예외 처리 등 다양한 측면에서 피드백을 줄 수 있지만,
- 그 피드백이 항상 정확하지는 않기 때문에 리뷰 내용을 비판적으로 해석하는 습관도 함께 기를 수 있다.

#### 2) 목표

- GPT에게 본인이 작성한 코드를 리뷰하게 하면서 코드 개선 포인트를 파악하는 연습을 한다.
- GPT의 피드백 중 타당하지 않거나 이해가 어려운 내용을 비판적으로 검토한다.
- AI를 통해 개발 역량을 점검하고 성장 도구로 활용하는 습관을 만든다.

#### 3) 달성 기준

- 본인이 직접 작성한 코드를 준비한다. (간단한 알고리즘, API 핸들러, 비즈니스 로직 등 자유 주제)
- GPT에게 코드 리뷰를 부탁하면서 바로 피드백 하기 보다는 개발자의 의도를 묻고 리뷰를 하라고 한다.
- GPT에게 "이 코드에 대해 코드 리뷰를 해줘. 가독성, 성능, 확장성, 예외 처리 측면에서 조언 부탁해.
- 다만, 개선할 부분에 대해서 나에게 의도를 질문해서 내가 그 코드를 그렇게 짠 이유를 이해하고, 그 다음에 리뷰를 해" 등으로 리뷰를 요청한다.
- GPT가 제안한 리뷰 중 타당한 피드백은 반영해 코드를 개선한다.
- 동의하지 않는 피드백이 있다면 그 이유를 스스로 설명하거나 GPT에게 다시 질문하여 반박 논리를 명확히 한다.
- 최종 결과물에는 코드 원본, GPT 리뷰 결과, 수정된 코드, 반영 여부 및 이유가 포함된다.

---

### [퀘스트 2: AI와 함께하는 팀 운세 점치기 (커뮤니티 아이스브레이킹) (유지)]

#### 1) 배경

- 매주 팀원들이 바뀌는데 첫 날의 아이스브레이킹은 쉽지 않다.
- 스몰톡을 할 만한 공통 주제거리가 있으면 대화가 자연스러워지고 팀 분위기가 좋아진다.
- 기존 미션 말고도 재미있는 얘기거리를 만들어 분위기를 활발하게 만들 필요가 있다.

#### 2) 목표

- 팀원들의 이름만 AI에 전달해 각자 오늘의 운세를 받아온다.
- 피어 세션 시작 시 모두에게 운세 결과를 공유해 웃으며 세션을 시작하게 만든다.
- 즐거운 대화 분위기 형성 및 세션 진행 원활화에 기여한다.

#### 3) 달성 기준

- 팀원 이름 리스트를 AI에 입력하고 운세 결과를 받는다
- 세션 시작 전 운세 결과를 팀원들에게 공유
- 팀원들의 대화 참여도 향상

---

### [퀘스트 3: 오히려 좋아 챌린지 (개선)]

#### 1) 배경

- 미션을 하다보면 힘든 상황만 계속 터지고, 스스로 부정적으로 변하기 쉽다.
- 어렵고 힘든 상황을 '오히려 좋아!'로 승화시키면서 긍정적으로 생각해보자.

#### 2) 목표

- 힘든 상황을 '오히려 좋아!'의 긍정적인 마인드로 승화시켜서 멘탈을 지키자.

#### 3) 달성 조건

- AI에게 오늘 미션을 하면서 힘들었던 일을 털어놓으며, '오히려 좋아!'로 승화시켜 달라고 요청한다.
- AI의 답변을 보고 에너지를 얻는다.
- 해당 미션을 수행하며 힘든 상황을 긍정적으로 생각하는 마인드를 장착한다.

---

# 퀘스트 수행

## J087\_김희원 - 퀘스트 1

<details>
    <summary><strong>개선전 알고리즘 문제 코드</strong></summary>

```js
function solution(arr) {
  const map = new Map();
  arr.forEach((value) => {
    map.set(value, (map.get(value) || 0) + 1);
  });
  return map;
}

function solution2(arr, target) {
  const map = new Map();
  for (let i = 0; i < arr.length; i++) {
    const v = arr[i];
    const y = target - v;
    if (map.has(y)) {
      return [map.get(y), i];
    }
    map.set(v, i);
  }
  return null;
}

const nums = [2, 7, 11, 15];
const target = 9;
console.log(solution2(nums, target));
```

</details>

<details>
    <summary><strong>개선후 알고리즘 문제 코드</strong></summary>

```js
/**
 * 값별 빈도수를 계산합니다.
 * @template T
 * @param {Iterable<T>} iterable
 * @returns {Map<T, number>}
 */
function countByValue(iterable) {
  const map = new Map();
  for (const v of iterable) {
    map.set(v, (map.get(v) ?? 0) + 1);
  }
  return map;
}

/**
 * 두 수의 합이 target이 되는 인덱스 쌍을 반환합니다.
 * 못 찾으면 null.
 * @param {number[]} arr
 * @param {number} target
 * @returns {[number, number] | null}
 */
function twoSumIndices(arr, target) {
  if (!Array.isArray(arr)) throw new TypeError('arr must be an array');
  if (!Number.isFinite(target))
    throw new TypeError('target must be a finite number');
  if (arr.length < 2) return null;

  const seen = new Map(); // value -> earliest index
  for (let i = 0; i < arr.length; i++) {
    const v = arr[i];
    if (!Number.isFinite(v)) continue; // 혹은 throw: 타입 정책에 맞춰 선택
    const need = target - v;

    if (seen.has(need)) {
      return [seen.get(need), i];
    }
    if (!seen.has(v)) seen.set(v, i); // 첫 등장 인덱스 고정
  }
  return null;
}

// 사용 예
const nums = [2, 7, 11, 15];
const target = 9;
console.log(twoSumIndices(nums, target)); // [0, 1]
```

</details>

**소감**

- 단순한 알고리즘 문제에서 연관지어 예외처리 로직 등에 대해 생각해 볼 수 있었다
- AI를 이용하여 능숙하게 코드를 리뷰하는 방법을 익힐 수 있었다.

---

## J131\_백지윤 - 퀘스트 3

<img width="712" height="747" alt="스크린샷 2025-08-08 오전 10 37 53" src="https://github.com/user-attachments/assets/4b1fc5bc-a259-468b-a8d6-59d845f90efa" />

### 1. 한 주 간의 진행

이번 주는 긍정적인 마인드를 유지하려는 퀘스트에 집중했다. 주어진 미션을 수행하면서 힘든 상황이 있었지만, 이를 "오히려 좋아!"라는 긍정적인 생각으로 승화시키려고 했다. 여러 번 AI와 대화를 통해 긍정적인 에너지를 얻었고, 그 덕분에 미션에 집중할 수 있었다.

### 3. AI 활용에서 좋았던 점

- 긍정적인 마인드 유지: 힘든 상황에서 AI와의 대화를 통해 긍정적인 마인드를 유지하는 데 큰 도움이 되었다. AI가 제공하는 긍정적인 피드백을 통해 멘탈을 유지하고, 에너지를 얻을 수 있었다.

- 자기 반성: AI가 미션 중 겪었던 문제에 대해 긍정적인 시각을 주었고, 이를 통해 자신의 실수나 부족한 부분을 더 잘 받아들이고 성장할 수 있었다.

### 4. AI 활용에서 아쉬운 점

- 기대에 못 미친 부분: AI가 제공하는 답변이 가끔은 너무 일반적이거나 추상적인 답변이 될 때가 있었다. 더 구체적이고 실용적인 조언을 받으면 좋겠다는 생각이 들었다. 특히 상황에 맞는 현실적인 해결책을 더 많이 받아볼 수 있으면 좋겠다고 느꼈다.

- 대화의 흐름: AI가 제공하는 답변이 때로는 조금 단편적이거나 다소 일관되지 않은 경우도 있었다. 대화를 좀 더 심도 깊고 세밀하게 이어갈 수 있었으면 좋겠다는 생각이 들었다.
  
## J203_김건우 - 퀘스트 1
## 수행
TCP 네트워크 과제를 수행하며 작성된 서버의 이벤트 핸들러를 완성시킨 뒤 AI에게 유지보수성과 가독성, 코드 재사용성, 로직의 오류 등을 종합하여 평가해달라고 요청했다.

---

### 코드

```js
// serverHandler
"use strict";
const net = require('net');
const message = require('./message');

/**
 * 연결 응답을 클라이언트에 전송합니다.
 * @param {boolean} success - 연결 성공 여부
 * @param {net.Socket} socket - 대상 클라이언트 소켓
 * @param {string|null} [reason=null] - 실패 시 사유 메시지
 */
function handleConnectAck(success, socket, reason = null) {
    message.sendConnected(socket, success, reason);
}

/** 생략 */

module.exports = {
    handleConnectAck,
    handleLoginAck,
    handleLogoutAck,
    handleCatalogAck
};
```

---

### 답변

**평가**
| 평가 항목       | 점수(5점 만점) | 코멘트                                      |
| ----------- | --------- | ---------------------------------------- |
| **유지보수성**   | 4.0       | 역할 분리는 명확하나, ACK 함수가 유형별로 중복되어 있음.       |
| **재사용성**    | 3.5       | 패턴이 같아 확장성은 높으나, 공통 유틸 부재로 매번 함수 추가 필요.  |
| **가독성**     | 4.5       | 네이밍·JSDoc 구조는 명확. 단, 파라미터 순서 불일치가 있음.    |
| **일관성**     | 3.5       | 대부분 동일하나 `handleLoginAck`만 인자 순서가 다름.    |
| **안전성**     | 3.0       | 소켓 무효/종료 상태에 대한 방어 코드 없음.                |
| **테스트 용이성** | 3.5       | 단순 구조라 스파이 가능하나, message 모듈이 하드 결합되어 있음. |

**잠재적 수정사항**
- DRY 통합 유틸: handleAck(type, socket, success, ...args) 단일 엔트리 + 내부 매핑.
- 시그니처 정렬: 모든 ACK 함수 인자 순서를 success, socket, payload?, reason?로 통일.
- JSDoc 보강: 선택 인자는 [] 표기, success=true/false 조건부 사용을 명확히 기술.
- 소켓 상태 방어: if (!socket || socket.destroyed) return; 가드 추가.
- 의존성 주입(DI): createAckHandler(messageModule) 형태로 팩토리화 → 테스트 시 mock 주입 용이.
- 에러 로깅 규칙: 미등록 타입/전송 실패 시 공통 로거 사용(warn/error 구분).

---

### AI와 의논

메시지 모듈이 하드결합 돼있다는 말이 이해가 잘 안돼서 하드결합된 방식이 아니도록 구현할 방법은 없는지에 대해 물어봤다.

AI는 다음과 같은 전략을 제시했다.

| 패턴                 | 결합도 완화 방식                   | 장점                      | 단점                | 적용 추천 상황               |
| ------------------ | --------------------------- | ----------------------- | ----------------- | ---------------------- |
| **1. 팩토리 기반 DI**   | 생성 시 `message` 모듈을 주입       | 구조 단순, 테스트 용이, 코드 추적 쉬움 | 매번 인스턴스 생성 필요     | 테스트 친화적·구현 단순한 경우      |
| **2. 전략 맵 DI**     | ACK 타입별 함수를 맵에 등록           | ACK 라우팅 깔끔, 추가/삭제 쉬움    | 타입 오타 런타임 에러 가능   | ACK 타입이 늘어날 가능성이 높은 경우 |
| **3. 런타임 레지스트리**   | 외부에서 `register()`로 송신 함수 주입 | 플러그인/핫스왑 가능, 확장성 높음     | 흐름 추적 어려움         | 런타임에 모듈 교체·확장이 필요한 경우  |
| **4. 어댑터 인터페이스**   | 계약(타입)만 의존, 구현 교체 가능        | 타입 안전성 높음, 교체 용이        | 초기 설계 시 계약 정의 필요  | 구현이 여러 버전 존재하는 경우      |
| **5. 이벤트 방출(IoC)** | ACK를 이벤트로 방출, 리스너에서 송신      | 다중 소비자 가능, 로깅/모니터링 쉬움   | 추적 어려움, 타입 안전성 낮음 | ACK 처리 파이프라인이 복잡한 경우   |
| **6. 서비스 로케이터**    | 전역 레지스트리에서 구현 획득            | 기존 코드 변경 최소화            | 전역 상태로 테스트 투명성 저하 | 레거시 코드에 최소 침습 적용 시     |


---

### 피드백 반영

아쉽게도 다른 부분을 작업하는데 예상보다 시간이 오래걸려 피드백을 반영하여 수정하지는 못했다.

----

### 회고
이전까지는 오류가 날 때마다 그 지점의 스니펫과 메시지를 보내 “어디가 문제인지”만 유추해 달라고 했다.
하지만 그런 방식이 내 성장을 돕느냐고 묻는다면, 단언컨대 아니다.
오류를 어떻게 고칠지 찾는 과정도 중요하지만, 이제는 그 순간을 “설계가 잘못된 신호”로 보고 더 넓은 시야에서 점검할 기회를 갖게 됐다.

## S040\_하종석 - 퀘스트 3
