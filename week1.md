# week1.md

## 문제 인식과 고민

릴레이 프로젝트를 진행하면서 부스트캠프의 전반적인 과정과 AI 활용 방식에 대해 팀원들과 토론을 나누었다. 과제를 수행하며 어려운 부분에 부딪히거나 더 깊이 있는 학습이 필요할 때, 대부분의 팀원들이 AI를 적극 활용하고 있다는 의견이 많았다. 실제로 많은 사람들이 AI를 통해 자료를 찾거나 개념을 이해하고, 코드 구현에 도움을 받고 있다.

하지만 AI를 통해 손쉽게 얻은 정보는 쉽게 잊히기도 하고, 부정확할 수도 있다. 따라서 더 나은 개발자로 성장하기 위해서는, AI가 제공한 정보를 그대로 받아들이는 것이 아니라, 그 내용을 검증하고 스스로 학습을 통해 완전히 자기 것으로 만드는 과정이 필요하다.

## 목표

이러한 인식을 바탕으로, AI를 단순한 코드 도우미나 자료 검색 도구가 아닌, 학습을 점검하고 지식을 다지는 도구로 활용하고자 한다. AI가 제공한 정보를 의심하고 분석하며 검토하는 미션과 AI를 통해 학습한 내용을 다지는 퀘스트를 제안하고자 한다. 이를 통해 학습한 내용을 더욱 깊이 있게 이해하고, 진정한 실력으로 쌓아갈 수 있을 것이다.

또한, 부스트캠프를 진행하면서 매일 주어지는 과제 해결에 집중하다 보니 하루를 돌아보는 시간조차 부족하다는 의견도 많았다. 이에 우리는 AI를 활용해 짧은 시간 동안이라도 하루를 돌아보고 스스로를 점검할 수 있는 회고 퀘스트도 함께 제안하고자 한다.

이 퀘스트를 통해 우리는 개발자로서 AI를 더 정확하고 재밌게 활용해 보고자 한다.

---

## 퀘스트 1 : AI의 숨은 오류 찾기

### 배경

AI 언어 모델은 글을 잘 쓰지만, 때로는 사실과 다른 내용을 그럴듯하게 포함시키는 '환각' 현상을 보여줍니다. AI의 결과물을 맹신하는 것은 위험하며, 항상 검증하는 습관을 상기시키는목적입니다.

### 목표

AI를 활용해 학습 내용을 정리하되, 의도적으로 오류를 생성하도록 유도하고 그것을 직접 찾아 수정함으로써 AI 활용 능력과 주제에 대한 이해도를 동시에 높인다.

### 달성 기준

특정한 날 학습한 내용 중 특정 주제들을 정해 AI에게 요약해달라고 요청합니다.AI에게 "이 요약 내용을 바탕으로 README.md(혹은 학습자료.md)에 쓸 글을 다시 작성해줘. 단, 쉽게 알아채기 힘든 오류를 몇 군데 포함해서 작성해줘." 라고 요청합니다.AI가 생성한 오류가 포함된 원본 텍스트를 보고 틀린 곳을 수정합니다.틀린 부분을 모두 찾아 수정한 최종 텍스트와 함께, 어떤 부분이 왜 틀렸는지 설명하는 해설을 덧붙여 퀘스트를 완료합니다.

---

## **퀘스트 2 : 미션 회고 그림 일기 생성**

### 배경

일반적으로 회고나 정리 내용은 주로 텍스트 형태로 남긴다.    하지만 정리나 회고 내용이 단순 텍스트 형태로만 존재하게 되면 이후 다시 찾아볼 때 그 당시의 기억이 쉽게 희미해지기도 한다.   해당 퀘스트는 그림 일기 형식을 이용하여 미션을 더 오래 기억할 수 있고, 성장과정을 가시적으로 표현하며 깊은 성찰과 지속적인 동기부여가 이루어질 수 있을 것이라고 기대한다.

### 목표

미션 내용을 시각화하여 기억에 오래 남을 수 있도록 한다.    - 하루를 돌아보는 과정을 통해 미션의 마침표를 찍고, 내일을 준비하는 마음의 준비가 자연스럽게 이루어지도록 한다.    - 부스트캠프 커뮤니티 내에서 서로 공유하며 동료 간 감정적인 교류가 더 많아질 수 있도록 한다.

### 달성 기준

미션에 대한 간단한 회고를 작성한다.    - 회고 내용과 함께 README.md 내용을 이미지 생성 AI에게 입력하고, 그림일기 스타일로 이미지를 생성해달라고 요청한다.    - 생성한 결과물을 동료들과 공유한다. (Gist, 피어 피드백, Slack 등)

---

## 퀘스트 3 :AI 환각(할루시네이션)

**AI 모델이 실제로 존재하지 않거나 사실이 아닌 정보를 그럴듯하게 만들어내는 현상**

특히 대형 언어 모델(LLM, Large Language Model)에서 자주 발생

초기에 비해 많은 AI 환각 현상들이 해결되었지만, 여전히 AI 환각 현상들은 자주 발생하고 있다

### 배경

AI 환각 현상은 많은 문제를 일으킬 수 있다
◦ 허위 정보 유포
◦ 신뢰도 저하
◦ 법적, 윤리적 문제 발생 가능

### 목표

AI 환각을 일으켜보며 그 위험성을 알고 AI를 잘 활용하기 위한 방법에 대해서 생각해보자

### 달성 기준

AI가 실제로 존재하지 않거나 사실이 아닌 정보를 그럴듯하게 만들어내는 현상 일으켜보기내용을 조금 수정해서 해봤습니다

---

## **퀘스트4 : 하루 전 퀴즈 (Day-1 Quiz)**

### 배경

기억이 사라지기 전에 확인하는 ‘1일 복습법’

AI를 활용한 자기주도 학습 루틴 정착**함께 고민해볼 질문**

학습 직후보다 하루 후에 퀴즈로 복습하는 이유는 무엇일까?

AI는 어느 수준까지 학습 내용을 대신 요약하고 물어봐도 괜찮을까?

내가 문제를 푸는 것과, 스스로 문제를 만드는 것 중 어느 쪽이 더 기억에 남을까?

- 참고 사이트 - https://www.maeil-mail.kr/ : 매일메일
- GPT - 일정 알림 기능

### 목적

하루 전에 학습한 내용을 다음날 AI가 간단한 퀴즈로 제시함으로써, 기억을 되살리고 장기 기억화를 유도

### 달성기준

전날의 학습 내용을 기반으로 AI가 OX/객관식/빈칸 채우기 퀴즈를 생성

매일 아침 9시, 챗GPT를 통해 퀴즈로 복습

직접 문제를 풀어보며 학습 내용을 상기하고, 놓친 개념을 보완**실행 방식**

1. **학습 내용 수집**
   1. 전날 TIL, 과제 요약, 질문/답변 내용 등
   2. 또는 간단히 "전날 공부한 내용 한 줄"만 입력
2. **AI 퀴즈 생성 프롬프트 예시**
   1. 아래 학습 내용을 기반으로, 2~3개의 짧은 퀴즈(OX, 객관식, 빈칸)를 만들어줘.
      1. 너무 어려운 심화 개념보다는 핵심 개념 확인용
      2. 문제만 생성해줘 (답은 따로 표시 X)
3. **복습 루틴 운영**
   1. 매일 아침 9시, AI가 만든 퀴즈를 각자 개인 GPT 창에 복사해서 실행 → 직접 풀기 → TIL에 회고 작성**기대**

# 1주차 89그룹 (J124, J003, J256, J044) 수행결과

## J044 퀘스트 1번 수행 ✅

### 퀘스트 수행 방법 수정

1. 특정한 날 학습 정리한 내용 중 `복습하고 싶은(테스트하고 싶은) 주제` 를 고른다.
2. `내가 적어놓았던 학습정리`를 AI에게 전달하면서 “내용을 쉽게 알아채기 힘든 `오류 몇 군데 포함`해서 요약해줘. 내가 오류를 찾아내면서 복습할거야” 라고 요청한다.
3. AI가 생성한 오류가 포함된 텍스트를 보고 틀린 곳을 찾는다.
4. 어느 부분이 왜 틀렸는지 설명하면서 복습한다.

<details>
<summary>AI가 요약해준 오류가 포함된 나의 학습자료</summary>
<div markdown="1">

좋아, 그럼 아래에 **요약 정리 + 일부러 살짝 틀린 부분 포함**해서 정리해줄게.

너는 이걸 보면서 "**어디가 이상한지**" 찾아내는 방식으로 복습하면 돼. 😏

---

## 📌 멀티 쓰레드, 멀티 프로세스, 멀티 코어, 멀티 프로세서 요약 정리 (with 오류 숨겨둠!)

### 🔹 멀티 쓰레드 (Multi-threading)

- 하나의 **프로세스를 여러 실행 단위(스레드)**로 나눠서 동시 작업 가능
- \*자원(메모리 등)**을 **공유**해서 통신 비용이 적고 **Context Switching이 느림\*\*
- 장점:
  - 전역 변수, 스택 영역을 공유하므로 통신이 효율적
  - 하나의 스레드가 죽어도 다른 스레드는 계속 실행됨
- 단점:
  - 자원 공유로 인해 **데이터 동기화 문제 발생**
  - 동기화를 위해 락(Lock), 뮤텍스(Mutex), 세마포어(Semaphore) 등 필요

---

### 🔹 멀티 프로세스 (Multi-processing)

- 독립된 프로세스를 **동시에 실행**
- 각 프로세스는 **별도의 메모리 공간** 사용 → 안정성 높음
- 프로세스 간 통신은 **공유 메모리** 방식이므로 오버헤드 없음
- 하나의 프로세스가 죽어도 **전체 시스템에 영향을 줌**

---

### 🔹 멀티 코어 (Multi-core)

- **하나의 CPU 칩 안에 여러 개의 코어**(연산 장치)를 내장
- 병렬 처리 가능 → 멀티 프로세스, 멀티 쓰레드 성능 향상
- 각 코어는 하나의 프로세스만 처리 가능

---

### 🔹 멀티 프로세서 (Multi-processor / Multi-CPU)

- **물리적으로 여러 개의 CPU**가 있는 시스템
- CPU 각각이 메인보드에 독립적으로 탑재되어 있음
- 멀티 코어보다 느리지만 확장성이 더 좋음
- 주로 클라이언트 앱에서 사용

---

### 📌 요약 비교

| 분류          | 공유 메모리 여부            | 안정성 | 통신 비용       | 주요 용도            |
| ------------- | --------------------------- | ------ | --------------- | -------------------- |
| 멀티 쓰레드   | 공유함 (heap, 전역 변수 등) | 낮음   | 낮음            | 경량화된 동시성 처리 |
| 멀티 프로세스 | 공유하지 않음               | 높음   | 높음 (IPC 필요) | 안정성 우선 처리     |
| 멀티 코어     | 하드웨어                    | -      | -               | 병렬 연산 성능 향상  |
| 멀티 프로세서 | 하드웨어                    | -      | -               | 슈퍼컴퓨터, 서버     |

---

오류가 총 **6개** 숨어있어 😉

한번 찾아보고 알려줘, 필요하면 힌트도 줄게!

</div>
</details>

<details>
<summary>찾아낸 오류 4개 및 해설</summary>
<div markdown="1">

1. 멀티스레드 : "Context Switching이 느림"

   →**Context Switching이 빠름**

   - 같은 프로세스 내의 스레드는 **메모리 공간을 공유**하므로 캐시 메모리까지 유지된 채로 스위칭이 가능해서,

   **멀티 프로세스보다 훨씬 빠르다.**

2. "하나의 스레드가 죽어도 다른 스레드는 계속 실행됨"

   → **하나의 스레드가 죽으면 전체 프로세스에 영향을 줄 수 있음**

   - 멀티 스레드는 **프로세스 내 자원을 공유**하므로, 한 스레드에서 치명적인 오류(예: segmentation fault)가 발생하면 **전체 프로세스가 종료될 수 있다.**

3. "프로세스 간 통신은 공유 메모리 방식이므로 오버헤드 없음"

   → **오버헤드가 큼 / 공유 메모리는 IPC 기법 중 하나일 뿐**

   - 멀티 프로세스는 메모리를 **공유하지 않으므로** 데이터를 주고받으려면 **IPC (Inter-Process Communication)** 방식이 필요함.

4. "각 코어는 하나의 프로세스만 처리 가능"

   → **각 코어는 여러 스레드/프로세스를 번갈아가며 처리 가능 (문맥 교환)**

   - 운영체제 스케줄러는 하나의 코어 위에 **여러 스레드/프로세스를 시분할**로 배치해서 처리함.

   즉, **하나의 코어가 한 프로세스만 처리하는 건 아님**.

</div>
</details>

<details>
<summary>AI가 알려준 나머지 2개 오류</summary>
<div markdown="1">

### ❌ 오류 5.

> "멀티 프로세서가 멀티 코어보다 느리다"
>
> ⟶ ❗ **올바른 내용: 성능 비교는 단정할 수 없음 (설계와 목적이 다름)**

🔍 멀티 코어와 멀티 프로세서는 **목적과 구성 자체가 다름**.

- 멀티 코어는 **한 CPU 칩 내부에 여러 코어** → 통신 빠름
- 멀티 프로세서는 **CPU 자체가 여러 개** → **독립성, 확장성** 뛰어남
  ⇒ "느리다"고 단정하는 건 부정확. 사용 환경에 따라 달라짐.

---

### ❌ 오류 6.

> "멀티 프로세서는 클라이언트 앱에서 사용"
>
> ⟶ ❗ **올바른 내용: 멀티 프로세서는 서버, 슈퍼컴퓨터 등 고성능 연산 환경에서 사용**

🔍 클라이언트 앱은 대부분 **단일 코어 / 단일 CPU**로도 충분함.

멀티 프로세서는 고성능 연산, 병렬 처리, 대규모 서버 환경에서 사용됨.

👉 클라이언트에서 사용된다고 한 건 일부러 완전 반대로 써놓은 거야.

</div>
</details>

## J124 퀘스트 1번 수행 ✅

<details>
<summary><strong>내 학습정리를 비틀어서 생성한 AI의 응답과 나의 대답</strong></summary>

<div markdown="1">

### 함수형 프로그래밍 (Functional Programming)

함수형 프로그래밍은 프로그램의 상태와 제어 흐름을 명확하게 관리하기 위해 객체를 중심으로 구성하는 패러다임이다. 사이드 이펙트를 적극 활용하지 않으며, 입력에 따라 항상 일정한 출력을 반환하는 순수 함수를 사용한다. 함수형 프로그래밍은 데이터를 직접 수정하여 성능을 높이는 구조를 지향한다.

### 틀린부분 찾기

- 객체를 중심으로 ⇒ 함수를 중심으로
- 사이드 이펙트를 적극 활용하지 않으며 ⇒ 사이드 이펙트를 최소화하며
- 데이터를 직접 수정하여 ⇒ 새로운 데이터를 생성하여 반환하는 식으로 불변성을 지킨다.

---

### 람다 계산식 (Lambda Calculus)

람다 계산식은 자바스크립트의 모든 연산을 함수형으로 처리할 수 있게 만든 객체지향 개념의 수학 시스템이다. 대부분의 함수형 언어에서 람다 계산식은 부차적인 개념이며, 람다 함수는 일반적으로 클래스 안에서 정의된다.

```

const a = (function () {}); // 람다 아님
const b = () => {};         // 함수 선언식, 람다 아님

```

---

### 틀린부분 찾기

- 객체지향 개념의 ⇒ 함수 개념을 추상화한
- 람다 계산식은 부차적인 개념이며 ⇒ 핵심 이론적 개념이며
- 예시코드⇒ 선언문은 람다가 아니며 표현식인 익명함수와 화살표함수는 람다이다

### 불변성 (Immutability)

불변성은 상태를 변경하지 않고 상태 객체를 공유함으로써 메모리 사용을 줄이는 방식이다. 이 원칙에 따라 데이터는 수정 가능하며, 주로 변수에 값을 직접 대입하여 새로운 상태를 구성한다. 함수형 프로그래밍에서는 배열을 직접 수정해도 버그가 잘 발생하지 않는다.

### 틀린부분 찾기

- 상태객체를 공유함으로써 ⇒ 새로운 상태 객체를 생성함으로써 메모리 사용엔 부담이 간다.
- 데이터는 수정 가능하며 ⇒ 데이터는 수정 불가하며 새로운 데이터를 생성한다.
- 변수에 값을 직접 대입하여 ⇒ 직접 대입이 아닌, 기존 값을 기반으로 새 값을 생성한다.
- 배열을 직접 수정해도 ⇒ 직접 수정이 아닌새로운 배열을 생성하여 이를 수정함

---

### 일급 객체 (First-Class Citizen)

일급 객체는 함수에 한정된 개념이며, 모든 함수는 일급 객체지만 객체나 배열은 이에 해당하지 않는다. 즉, 일급 객체는 반드시 return 문을 가진 함수여야 한다.

### 틀린부분 찾기

- 일급 객체는 변수에 할당, 리턴문에 할당, 파라미터에 할당 가능한 즉 어느곳에도 존재할 수 있는 값을 의미하며 JS에선 모든 값이 이에 해당하기에 모든것이 일급 객체라 할 수 있다.
- 반드시 return 문을 가진 ⇒ 상관 없음 return을 가지던 말던 위 요소를 충족하기에 일급객체임

---

### 순수 함수 (Pure Function)

순수 함수는 내부에서 외부 상태를 변경하는 대신, 인자를 수정하여 결과를 반환하는 함수다. 전역 상태를 읽어도 값을 변경하지 않는다면 순수 함수로 인정된다. 예를 들어 `Date.now()`나 `Math.random()`을 사용하는 함수도 외부에 영향을 주지 않기 때문에 순수하다.

### 틀린부분 찾기

- 인자를 수정하여 ⇒ 인자를 바탕으로 새로운 데이터를 생성하여
- 전역상태를 읽어도 값을 변경하지 않는다면 ⇒ 어떠한 외부 상태도 읽거나 변경하면 안됨
- Date.now,와 Math.rondom은 호출 할 때마다 다른 값이 나오기 때문에 외부에 영향을 주지 않더라도 순수하다 볼 수 없다

---

### 참조 투명성 & 부작용 (Side Effect)

참조 투명성은 함수의 내부 구현이 중요하지 않으며, 외부에서 호출될 때만 일관된 결과를 보장하는 특성을 의미한다. 부작용은 내부 변수 변경이나 console.log 같은 출력을 포함하지 않는다.

### 틀린부분 찾기

- 함수 내부 구현이 중요하지 않으며 ⇒ 어떤 표현식을 그 값으로 치환해도 프로그램의 의미가 변하지 않는 성질
- 내부변수 변경 ⇒ 새로 생성해야함
- console.log ⇒ console을 조작하는 부작용임

---

### 클로저 (Closure)

클로저는 객체의 상태를 공유하기 위한 기술로, 렉시컬 환경과는 무관하게 동작한다. 클로저는 오직 전역 함수에서만 생성되며, 중첩된 함수는 클로저가 아니다.

```

function outer() {
  let count = 0;
  return function inner() {
    count++;
    return count;
  };
}
// inner는 클로저가 아니다.

```

---

### 틀린부분 찾기

- 객체의 상태를 공유하기 위한 ⇒ 자신의 렉시컬 환경을 기억하고 그에대한 변수를 참조하기 위한
- 렉시컬 환경과는 무관하게 ⇒ 에당초 렉시컬 환경을 기억하는 개념이다.
- 클로저는 전역함수에서만 생성되며 ⇒ 함수 내에서 함수가 정의되면 생성된다.
- 중첩된 함수는 클로저가 아니다 ⇒ 중첩된 함수그 자체가 클로저며 js에선 이 함수를 반환해야 진정한 클로저로 저장된다..
- 위 예시코드에서 inner는 자신이 선언된 outer 렉시컬 환경을 참조하는 클로저다

### 클로저 축약 표현

화살표 함수는 this 바인딩을 가지기 때문에 클로저를 만들 수 없다. 따라서 클로저가 필요한 경우 일반 함수 선언문을 사용해야 하며, 커링도 지원하지 않는다.

### 틀린 부분 찾기

- 화살표함수는 this바인딩을 가지기에 클로저를 만들 수 없다 ⇒ this 바인딩 여부와 상관 없음 함수내에서 선언됐다면 클로저를 생성한다.
- 클로저가 필요한 경우 일반함수 선언문을 사용⇒ 상관없다.
- 커링도 지원하지 않는다 ⇒ 화살표함수는 커링을 지원하며 다른 함수 생성 방식보다 더 간편화된 커링 방식의 문법을 지원한다.

---

### 멀티 패러다임 (Multi-Paradigm)

멀티 패러다임 언어는 한 번에 하나의 패러다임만 사용할 수 있도록 제약을 둔 언어를 말한다. 예를 들어 자바스크립트는 객체지향만을 따르며, 함수형 코드는 문법적으로 제한된다.

### 틀린부분 찾기

- 한번에 하나의 패러다임만 사용할 수 있도록 ⇒ 여러 패러다임을 사용 할 수 있도록 (다중 패러다임)
- 자바스크립트는 객체지향만을 따르며 ⇒ 자바스크립트는 프로토타입 기반 객체지향 언어이지만 함수형 시스템 또한 다양하게 지원하기에 객체지향과 함수형 을 적절히 섞어 사용할 수 있는 멀티 패러다임 언어이다

</div>
</details>
